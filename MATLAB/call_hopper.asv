% function [t_out, y_state,e] = call_hopper()

tstart = 0;
tfinal = 5;

% set p;
p = hopperParameters();
p.x_dot_des = 3; %m/s

% set the state!
% remember: yfoot is 2. we should really be setting p.fsm_state after y0.
% y0 = [0.0; 0.4; 0.01; 0.0; 1.0; zeros(5,1)];
x_0 = 0.0; y_0 = 0.4; legrad_vert_0 = 0.01; bodyrad_vert_0 = 0.0; l_0 = 1;
X0 = [x_0; y_0; legrad_vert_0; bodyrad_vert_0; l_0; zeros(5,1)]; %standard start 20160501.
% y0 = [0.0; 0.4; 0.00; 0.0; 1.0; zeros(5,1)]; %vertical.

%
p.t_state_switch = tstart;
options = odeset('Events',@eventsHopperControl,'reltol',1e-8,'abstol',1e-8);
sr_sim = 1000;
%%
% t_out  -> time vector
% y_out  -> state vector
% te_out -> event time vector
% ye_out  -> state at event time vector
% ie_out  -> event index
% at_des  -> 

[t_out,y_out,te_out,ye_out,ie_out,c_state,at_des,extra_states,stated_out] = deal([]);

replication_data = {};
tic;
while tstart < tfinal
    % Solve until the first terminal event.
    [sol] = ode45(@hopperDynamics,[tstart,tfinal],X0,options,p);
    % Accumulate output.
    t = [tstart:1/sr_sim:sol.x(end),sol.x(end)];
    states = deval(sol,t);
    states = states';%now n_t x n_states.
    t = t(1:end-1);
    t_out = [t_out; t'];

    % build c_state, a vector of control states
    if ~isempty(sol.ie)
        c_state = [c_state;repmat(p.fsm_state,length(t),1,1)];
    else
        c_state = [c_state;repmat(c_state(end),length(t),1,1)];
    end
    y_out = [y_out; states(1:end-1,:)];
    te_out = [te_out(:); sol.xe];    % Events at tstart are never reported.
    ye_out = [ye_out(:); sol.ye];
    ie_out = [ie_out(:); sol.ie];



    % FSMvars: set p.T_s and T_compression
    switch p.fsm_state %the state that we are in.
        case p.FSM_THRUST
            p.T_s = (t(end)-tstart) + p.T_compression;
            %             fprintf(['resetting T_s to ',num2str(p.T_s),'.\n']);
        case p.FSM_COMPRESSION
            p.T_compression = t(end)-tstart;
    end

    % hysteresis! hidden control state p.t_thrust_on
    if p.fsm_state == p.FSM_COMPRESSION % the state before thrust.
        % since we just got an event, we are leaving compression.
        % note the time t_thurst_on then. 
        p.t_thrust_on = t(end);
    end

    %%% STEP2 logging only
    % log1 grab control parameters, ONLY compute desired angle if we are in
    % flight. This might not be necessary. 
    if ~isempty(sol.ye) && p.fsm_state == p.FSM_FLIGHT
        strOut = hopperDynamicsFwd(sol.xe,sol.ye,p);
        at_des = [at_des;sol.xe,strOut.a_des];
    end

    % log {p, input, output} for saving to check hopperDynamicsForward
    int_extra_states = [];
    for iint =1:length(t)
        fwd_states = hopperDynamicsFwd(t(iint),states(iint,1:end)',p);
        int_extra_states(iint,:) = [fwd_states.u',fwd_states.fsm_state];
        
        % note: this should be the same as the %grab_control_parameters.
        % but need to check before simplifying code. 
        at_des_end = fwd_states.a_des(end);

        % replication_data log
        replication_cur = struct('t', t(iint),...
            'state',states(iint,1:end),...
            'p',p,...
        'state_d',fwd_states.stated);
        replication_data{end+1} = replication_cur;
    end
    extra_states = [extra_states;int_extra_states];
    

    %%% STEP2 logging only
    
    %%% STEP3: move ahead state machine
    if (~isempty(sol.ie))
        p.fsm_state = p.fsm_state+1;
        p.fsm_state = mod(p.fsm_state,p.FSM_NUM_STATES);
    end
    %%% /STEP3: move ahead state machine

    %%% STEP4: ICs for the next ode45() IVP call.
    X0 = y_out(end,:);
    tstart = t(end);
    %%% /STEP4 
end
toc;
%% we should be able to check that the u's are correct.


%% VELOCITY CONTROL. plot feedback around COM velocity
%  and our control of velocity, which is foot placement
figure;
d_xfoot_dt = y_out(:,6);dldt = y_out(:,10);l = y_out(:,5);dadt = y_out(:,8);
a = y_out(:,3);b = y_out(:,4);dbdt=y_out(:,9);
d_xbody_dt = d_xfoot_dt + dldt .* sin(a) + l .* dadt .* cos(a) + p.l_2 * dbdt .* cos(b);
subplot(2,1,1);
plot(t_out,d_xbody_dt);
hold on;
xl = xlim;
line([xl(1),xl(2)],[p.x_dot_des,p.x_dot_des]);
% plot desired angle of the foot against actual angle at collision.
subplot(2,1,2);
plot(t_out,y_out(:,3))
hold on;
plot(at_des(:,1),at_des(:,2),'rx')
%%
doStatePlot = 0;
if doStatePlot
    figure;
    subplot(2,1,1);plot(t_out,y_out(:,1:5))
    subplot(2,1,2);plot(t_out,y_out(:,6:10));
end
%%
doEventsPlot = 0;
if doEventsPlot
    events_mat = [-y_out(:,10)-.2,-(p.r_s0 - y_out(:,5))-.0001,y_out(:,2),-y_out(:,2)];
    figure;plot(t_out, events_mat);
end
%% body control during contact.
figure;
ah =[];
ah(1)=subplot(2,1,1);
plot(t_out,y_out(:,2:4));legend('yfoot','foot angle','body angle');
grid on;
ah(2)=subplot(2,1,2);
feedback_ang = y_out(:,4)-y_out(:,3)/2;
plot(t_out,feedback_ang,'r'); grid on; line([xlim],[0,0]);
linkaxes(ah,'x');
title('foot, ')
%%
sr_video = 24;
dur_frame = 1/sr_video;
ds = round(sr_sim/sr_video);
tout_vid = t_out(1:ds:length(t_out));
yout_vid = y_out(1:ds:length(y_out),1:5);
for i =1:length(yout_vid)
    tic;
    draw(p,tout_vid(i),yout_vid(i,1:5));
    dur_draw = toc;
    if dur_draw<dur_frame
        pause(dur_frame-dur_draw);
    end
    drawnow;
end

%%
y_state = struct;
y_state.x_foot = y_out(:,1);
y_state.z_foot = y_out(:,2);
y_state.phi_leg = y_out(:,3);
y_state.phi_body = y_out(:,4);
y_state.len_leg = y_out(:,5);
y_state.ddt_x_foot = y_out(:,6);
y_state.ddt_z_foot = y_out(:,7);
y_state.ddt_phi_leg = y_out(:,8);
y_state.ddt_phi_body = y_out(:,9);
y_state.ddt_len_leg = y_out(:,10);
y_state.u = extra_states(:,1:2);
y_state.fsm_state = extra_states(:,3);
% NEAR_0 = 1e-5;
% ind_near_0 = abs(y_state.u(:,1)) < NEAR_0;
% 20160123
% condition u to cover numerical errors about 0?
% cumtrapz produces improper integral of input force axial to leg.
% y_state.u(ind_near_0) = 0;
%%
e = hopperEnergy(t_out,y_state,p);

%% check
stated = replication_data{1}.state_d;
out = hopperDynamicsFwd(replication_data{1}.t,replication_data{1}.state(:),replication_data{1}.p)
